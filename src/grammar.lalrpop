use std::str::FromStr;
use crate::ast::{
    BinaryOp, Expr, FunctionCall, FunctionDeclaration, Header, IfElse, Literal, Parameter, Program,
    Statement, Type, UnaryOp, VariableAssignment, VariableDeclaration, While,
};

use lalrpop_util::ParseError;

grammar;

pub Program: Box<Program> = {
    <h: Header> => Box::new(Program{ header: h }),
};

pub Header: Header = {
    "program" <Identifier> => Header::Identifier(<>),
};

pub FunctionDeclaration: FunctionDeclaration = {
    "function" <i: Identifier> "(" <p: ParameterList> ")" ":" <t: Type> ";" <v: VariableDeclarationBlock> <s: Block> ";" => {
        FunctionDeclaration{
            identifier: i,
            parameter_list: p,
            return_type: Some(t),
            variable_declaration: v,
            body: s,
        }
    },
    "procedure" <i: Identifier> "(" <p: ParameterList> ")" ";" <v: VariableDeclarationBlock> <s: Block> ";" => {
        FunctionDeclaration{
            identifier: i,
            parameter_list: p,
            return_type: None,
            variable_declaration: v,
            body: s,
        }
    },
};

pub ParameterList: Vec<Parameter> = {
    <v: ParameterListNotEmpty> => v,
    () => vec![],
};

ParameterListNotEmpty: Vec<Parameter> = {
    <mut v: ParameterListNotEmpty> ";" <e: Parameter> => {
        v.extend(e);
        v
    },
    Parameter => <>,
};

pub Parameter: Vec<Parameter> = {
    <v: (<Identifier> ",")*> <e: Identifier> ":" <t: Type> => {
        let mut param: Vec<Parameter> = v
            .iter()
            .map(|elem| Parameter {
                identifier: elem.to_string(),
                typ: t.clone(),
            })
            .collect();
        param.push(Parameter {
            identifier: e,
            typ: t,
        });
        param
    },
};

pub VariableDeclarationBlock: Vec<VariableDeclaration> = {
    <v: ("var" <VariableDeclaration*>)?> => match v {
        None => vec![],
        Some(v) => v,
    },
};

pub VariableDeclaration: VariableDeclaration = {
    <i: Identifier> ":" <t: Type> <e: ("=" <Expr>)?> ";" => {
        VariableDeclaration{ identifier: i, typ: t, expr: e }
    },
};

Type: Type = {
    "integer" => Type::Integer,
    "double" => Type::Double,
    "boolean" => Type::Boolean,
    "string" => Type::String,
};

Statement: Statement = {
    MatchedStatement,
    UnmatchedStatement,
};

pub MatchedStatement: Statement = {
    VariableAssignment => Statement::VariableAssignment(<>),
    Block => Statement::Block(<>),
    MatchedIf => Statement::IfElse(<>),
    MatchedWhile => Statement::While(<>),
};
pub UnmatchedStatement: Statement = {
    UnmatchedIf => Statement::IfElse(<>),
    UnmatchedWhile => Statement::While(<>),
};

pub MatchedIf: IfElse = {
    "if" "(" <expr: Expr> ")" "then" <i: MatchedStatement> "else" <e: MatchedStatement> => {
        IfElse{ 
            expr: expr, 
            if_statement: Box::new(i), 
            else_statement: Some(Box::new(e)), 
        }
    },
};
pub UnmatchedIf: IfElse = {
    "if" "(" <expr: Expr> ")" "then" <i: Statement> => {
        IfElse{ 
            expr: expr, 
            if_statement: Box::new(i), 
            else_statement: None, 
        }
    },
    "if" "(" <expr: Expr> ")" "then" <i: MatchedStatement> "else" <e: UnmatchedStatement> => {
        IfElse{ 
            expr: expr, 
            if_statement: Box::new(i), 
            else_statement: Some(Box::new(e)), 
        }
    },
};

While<StatementType>: While = {
    "while" "(" <e: Expr> ")" "do" <s: StatementType> => {
        While{ expr: e, statement: Box::new(s) }
    },
};
pub MatchedWhile: While = {
    While<MatchedStatement>,
};
pub UnmatchedWhile: While = {
    While<UnmatchedStatement>,
};

pub VariableAssignment: VariableAssignment = {
    <i: Identifier> ":=" <e: Expr> => {
        VariableAssignment{ identifier: i, expr: e }
    },
};

pub Block: Vec<Statement> = {
    "begin" <mut v: (<Statement> ";")*> <e: Statement> (";")? "end" => {
        v.push(e);
        v
    },
};

pub FunctionCall: FunctionCall = {
    <i: Identifier> "(" <a: ArgumentList> ")" => {
        FunctionCall{ identifier: i, arguments: a }
    },
};

pub ArgumentList: Vec<Box<Expr>> = {
    <v: Args> => v,
    () => vec![],
};

Args: Vec<Box<Expr>> = {
    <mut v: Args> "," <e: Expr> => {
        v.push(e);
        v
    },
    Expr => vec![<>],
};

Tier<Op, NextTier>: Box<Expr> = {
    Tier<Op, NextTier> Op NextTier => Box::new(Expr::Binary(<>)),
    NextTier,
};

pub Expr: Box<Expr> = Tier<CmpOp, AddExpr>;
AddExpr: Box<Expr> = Tier<AddOp, MulExpr>;
MulExpr: Box<Expr> = Tier<MulOp, UnaryExpr>;

CmpOp: BinaryOp = {
    "=" => BinaryOp::Eq,
    "<" => BinaryOp::Lt,
    ">" => BinaryOp::Gt,
    "<=" => BinaryOp::Le,
    ">=" => BinaryOp::Ge,
    "<>" => BinaryOp::Neq,
};

AddOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
    "or" => BinaryOp::Or,
};

MulOp: BinaryOp= {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
    "and" => BinaryOp::And,
};

pub UnaryExpr: Box<Expr> = {
    UnaryOp UnaryExpr => Box::new(Expr::Unary(<>)),
    Term,
};

UnaryOp: UnaryOp = {
    "+" => UnaryOp::Pos,
    "-" => UnaryOp::Neg,
    "not" => UnaryOp::Not,
};

pub Term: Box<Expr> = {
    Literal => Box::new(Expr::Literal(<>)),
    Identifier => Box::new(Expr::Identifier(<>)),
    "(" <Expr> ")",
    FunctionCall => Box::new(Expr::FunctionCall(<>)),
};

Literal: Literal = {
    Integer => Literal::Integer(<>),
    Double => Literal::Double(<>),
    String => Literal::String(<>),
    Boolean => Literal::Boolean(<>),
};

Integer: i32 = {
    r"[0-9]+" =>? i32::from_str(<>)
        .map_err(|_| ParseError::User {
            error: "number is too big"
        }),
};

Double: f64 = {
    r"[0-9]+\.[0-9]+" =>? f64::from_str(<>)
        .map_err(|_| ParseError::User {
            error: "number is too big"
        }),
};

pub String: String = {
    r"'[^']*'" => <>.to_string(),
};

Boolean: bool = {
    "true" => true,
    "false" => false,
};

Identifier: String = {
    Id => <>.to_string(),
};

match {
    // String match
    "program",

    // Operators
    // Arithmetic
    "+", "-", "*", "/", "%",
    // Comparison
    "=", "<", ">", "<=", ">=", "<>",
    // Boolean
    "and", "or", "not",

    // TODO: Create better ordering
    "(", ")",
    ":", ";", ":=", ",",
    "true", "false",
    "integer", "double", "boolean", "string",
    "begin", "end",
    "if", "then", "else",
    "while", "do",
    "var",
    "function", "procedure",

    // Skip
    r"\s*" => { }, // Whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // Comments
    r"\(\*[\s\S]*\*\)" => { },
    r"\{[^}]*\}" => { },
} else {
    // Low prio
    r"[0-9]+",
    r"[0-9]+\.[0-9]+",
    r"'[^']*'",
    r"[a-zA-Z_][a-zA-Z0-9_]*" => Id,
}
