use std::str::FromStr;
use crate::ast::{
    BinaryOp, Expr, Header, IfElse, Literal, Program, Statement, Type, UnaryOp, VariableAssignment,
    VariableDeclaration,
};

use lalrpop_util::ParseError;

grammar;

pub Program: Box<Program> = {
    <h: Header> => Box::new(Program{ header: h }),
};

pub Header: Header = {
    "program" <Id> => Header::Identifier(<>.to_string()),
};

Tier<Op, NextTier>: Box<Expr> = {
    Tier<Op, NextTier> Op NextTier => Box::new(Expr::Binary(<>)),
    NextTier,
};

pub Expr: Box<Expr> = Tier<CmpOp, AddExpr>;
AddExpr: Box<Expr> = Tier<AddOp, MulExpr>;
MulExpr: Box<Expr> = Tier<MulOp, UnaryExpr>;

CmpOp: BinaryOp = {
    "=" => BinaryOp::Eq,
    "<" => BinaryOp::Lt,
    ">" => BinaryOp::Gt,
    "<=" => BinaryOp::Le,
    ">=" => BinaryOp::Ge,
    "<>" => BinaryOp::Neq,
};

AddOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
    "or" => BinaryOp::Or,
};

MulOp: BinaryOp= {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
    "and" => BinaryOp::And,
};

pub UnaryExpr: Box<Expr> = {
    UnaryOp UnaryExpr => Box::new(Expr::Unary(<>)),
    Term,
};

UnaryOp: UnaryOp = {
    "+" => UnaryOp::Pos,
    "-" => UnaryOp::Neg,
    "not" => UnaryOp::Not,
};

pub Term: Box<Expr> = {
    Literal => Box::new(Expr::Literal(<>)),
    Identifier => Box::new(Expr::Identifier(<>)),
    "(" <Expr> ")",
};

Literal: Literal = {
    Integer => Literal::Integer(<>),
    Double => Literal::Double(<>),
    String => Literal::String(<>),
    Boolean => Literal::Boolean(<>),
};

Integer: i32 = {
    r"[0-9]+" =>? i32::from_str(<>)
        .map_err(|_| ParseError::User {
            error: "number is too big"
        }),
};

Double: f64 = {
    r"[0-9]+\.[0-9]+" =>? f64::from_str(<>)
        .map_err(|_| ParseError::User {
            error: "number is too big"
        }),
};

pub String: String = {
    r"'[^']*'" => <>.to_string(),
};

Boolean: bool = {
    "true" => true,
    "false" => false,
};

Identifier: String = {
    Id => <>.to_string(),
};

pub VariableDeclaration: VariableDeclaration = {
    <i: Id> ":" <t: Type> <e: ("=" <Expr>)?> ";" => {
        VariableDeclaration{ identifier: i.to_string(), typ: t, expr: e }
    },
};

Type: Type = {
    "integer" => Type::Integer,
    "double" => Type::Double,
    "boolean" => Type::Boolean,
    "string" => Type::String,
};

Statement: Statement = {
    MatchedStatement,
    UnmatchedStatement,
};

pub MatchedStatement: Statement = {
    VariableAssignment => Statement::VariableAssignment(<>),
    Block => Statement::Block(<>),
    MatchedIf => Statement::IfElse(<>),
};

pub MatchedIf: IfElse = {
    "if" "(" <expr: Expr> ")" "then" <i: MatchedStatement> "else" <e: MatchedStatement> => {
        IfElse{ 
            expr: expr, 
            if_statement: Box::new(i), 
            else_statement: Some(Box::new(e)), 
        }
    },
};

UnmatchedStatement: Statement = {
    UnmatchedIf => Statement::IfElse(<>),
};

pub UnmatchedIf: IfElse = {
    "if" "(" <expr: Expr> ")" "then" <i: Statement> => {
        IfElse{ 
            expr: expr, 
            if_statement: Box::new(i), 
            else_statement: None, 
        }
    },
    "if" "(" <expr: Expr> ")" "then" <i: MatchedStatement> "else" <e: UnmatchedStatement> => {
        IfElse{ 
            expr: expr, 
            if_statement: Box::new(i), 
            else_statement: Some(Box::new(e)), 
        }
    },
};

pub VariableAssignment: VariableAssignment = {
    <i: Id> ":=" <e: Expr> => {
        VariableAssignment{ identifier: i.to_string(), expr: e }
    },
};

pub Block: Vec<Statement> = {
    "begin" <mut v: (<Statement> ";")*> <e: Statement> (";")? "end" => {
        v.push(e);
        v
    },
};

match {
    // String match
    "program",

    // Operators
    // Arithmetic
    "+", "-", "*", "/", "%",
    // Comparison
    "=", "<", ">", "<=", ">=", "<>",
    // Boolean
    "and", "or", "not",
    "if", "then", "else",

    "(", ")",
    ":", ";", ":=",
    "true", "false",
    "integer", "double", "boolean", "string",
    "begin", "end",

    // Skip
    r"\s*" => { }, // Whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // Comments
    r"\(\*[\s\S]*\*\)" => { },
    r"\{[^}]*\}" => { },
} else {
    // Low prio
    r"[0-9]+",
    r"[0-9]+\.[0-9]+",
    r"'[^']*'",
    r"[a-zA-Z_][a-zA-Z0-9_]*" => Id,
}
